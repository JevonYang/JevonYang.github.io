<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>  · JevonYang的博客</title><meta name="description" content=" - JevonYang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://jevonyang.github.io/atom.xml" title="JevonYang的博客"><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="JevonYang的博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/JevonYang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title"></h1><div class="post-info">Jan 13, 2021</div><div class="post-content"><h2 id="Project-Reactor中的Cache对象"><a href="#Project-Reactor中的Cache对象" class="headerlink" title="Project Reactor中的Cache对象"></a>Project Reactor中的Cache对象</h2><p>虽然reactor-netty使用nio的方式读写数据源大大加快了程序的响应速度，但是无论使用什么方法，远程数据读写都无法追赶上本地缓存的速度。</p>
<p>Project Reactor也提供了Cache的接入手段。在加入以下依赖，即可使用缓存对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.projectreactor.addons&#x2F;reactor-extra --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.projectreactor.addons&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;reactor-extra&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.4.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li><a target="_blank" rel="noopener" href="https://projectreactor.io/docs/extra/release/api/reactor/cache/CacheMono.html#CacheMono--">CacheMono</a></li>
<li><a target="_blank" rel="noopener" href="https://projectreactor.io/docs/extra/release/api/reactor/cache/CacheFlux.html#CacheFlux--">CacheFlux</a></li>
</ol>
<p>从名字上可以看出，<code>CacheMono</code>和<code>Mono</code>相对，代表[0..1]的对象，<code>CacheFlux</code>和<code>Flux</code>相对，代表[0..N]的对象。</p>
<p>事实上,在Spring Cloud Gateway源码中，就使用到了<code>CacheFlux</code>，用于缓存路由信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public CachingRouteDefinitionLocator(RouteDefinitionLocator delegate) &#123;</span><br><span class="line">		this.delegate &#x3D; delegate;</span><br><span class="line">		routeDefinitions &#x3D; CacheFlux.lookup(cache, &quot;routeDefs&quot;, RouteDefinition.class)</span><br><span class="line">				.onCacheMissResume(this.delegate::getRouteDefinitions);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CacheFlux官方文档例子"><a href="#CacheFlux官方文档例子" class="headerlink" title="CacheFlux官方文档例子"></a>CacheFlux官方文档例子</h2><p>官方一下两个例子，一个是<code>Generic cache entry points</code>，另一个是<code>Map endpoints</code></p>
<h3 id="Generic-cache-entry-points"><a href="#Generic-cache-entry-points" class="headerlink" title="Generic cache entry points"></a>Generic cache entry points</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AtomicReference&lt;Context&gt; storeRef &#x3D; new AtomicReference&lt;&gt;(Context.empty());</span><br><span class="line">   Flux&lt;Integer&gt; cachedFlux &#x3D; CacheFlux</span><br><span class="line">              .lookup(k -&gt; Mono.justOrEmpty(storeRef.get().getOrEmpty(k))</span><br><span class="line">                               .cast(Integer.class)</span><br><span class="line">                               .flatMap(max -&gt; Flux.range(1, max)</span><br><span class="line">                                                   .materialize()</span><br><span class="line">                                                   .collectList()),</span><br><span class="line">                              key)</span><br><span class="line">              .onCacheMissResume(Flux.range(1, 10))</span><br><span class="line">              .andWriteWith((k, sigs) -&gt; Flux.fromIterable(sigs)</span><br><span class="line">                                             .dematerialize()</span><br><span class="line">                                             .last()</span><br><span class="line">                                             .doOnNext(max -&gt; storeRef.updateAndGet(ctx -&gt; ctx.put(k, max)))</span><br><span class="line">                                             .then());</span><br></pre></td></tr></table></figure>
<h3 id="Map-endpoints"><a href="#Map-endpoints" class="headerlink" title="Map endpoints"></a>Map endpoints</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String key &#x3D; &quot;myCategory&quot;;</span><br><span class="line">LoadingCache&lt;String, Object&gt; graphs &#x3D; Caffeine</span><br><span class="line">    .newBuilder()</span><br><span class="line">    .maximumSize(10_000)</span><br><span class="line">    .expireAfterWrite(5, TimeUnit.MINUTES)</span><br><span class="line">    .refreshAfterWrite(1, TimeUnit.MINUTES)</span><br><span class="line">    .build(key -&gt; createExpensiveGraph(key));</span><br><span class="line"></span><br><span class="line">Flux&lt;Integer&gt; cachedMyCategory &#x3D; CacheFlux</span><br><span class="line">    .lookup(graphs.asMap(), key, Integer.class)</span><br><span class="line">    .onCacheMissResume(repository.findAllByCategory(key));</span><br></pre></td></tr></table></figure>
<p>我们以Map endpoints的例子说明。</p>
<p>在上面<code>Map endpoints</code>的例子上可以看到,使用了<code>Caffeine</code>缓存，这里也可以换成<code>Guava Cache</code>或者<code>ConcurrentHashMap</code>甚至<code>Hashmap</code>，使用<code>Hashmap</code>的时候，取决并发逻辑，尤其在写缓存的时候。</p>
<p>代码逻辑很简单，通过<code>lookUp</code>方法查找缓存，如果没有找到，通过<code>onCacheMissResume</code>方法查找数据源。</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>在定义了LoadingCache，我希望使用<code>refresh(key)</code>的方式更新缓存，但是发生问题。下面是我使用的<code>LoadingCache.build()</code>方法定义的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.build(new CacheLoader&lt;String, Object&gt;() &#123;</span><br><span class="line">	@Override</span><br><span class="line">    public YourType load(String key) throws Exception &#123;</span><br><span class="line">    	return getYourTypeValue(key); &#x2F;&#x2F; 同步代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>但是在刷新缓存后，再使用<code>CacheFlux</code>则会报错:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content of cache for key xxx cannot be cast to List&lt;Signal&gt;</span><br></pre></td></tr></table></figure>
<p>说一个不成熟的<strong>结论</strong>：</p>
<p><strong>不能通过<code>refresh()</code>方法来刷新缓存</strong></p>
<p>为什么会这样？我们接下来看一这一块的源码是如何写的。</p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;KEY, VALUE&gt; FluxCacheBuilderMapMiss&lt;VALUE&gt; lookup(Map&lt;KEY, ? super List&gt; cacheMap, KEY key, Class&lt;VALUE&gt; valueClass) &#123;</span><br><span class="line">	return otherSupplier -&gt;</span><br><span class="line">		Flux.defer(() -&gt; &#123;</span><br><span class="line">			Object fromCache &#x3D; cacheMap.get(key);</span><br><span class="line">            if (fromCache &#x3D;&#x3D; null) &#123;</span><br><span class="line">				return otherSupplier.get()</span><br><span class="line">					.materialize()</span><br><span class="line">					.collectList()</span><br><span class="line">					.doOnNext(signals -&gt; cacheMap.put(key, signals))</span><br><span class="line">					.flatMapIterable(Function.identity())</span><br><span class="line">					.dematerialize();</span><br><span class="line">			&#125; else if (fromCache instanceof List) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">					List&lt;Signal&lt;VALUE&gt;&gt; fromCacheSignals &#x3D; (List&lt;Signal&lt;VALUE&gt;&gt;) fromCache;</span><br><span class="line">					return Flux.fromIterable(fromCacheSignals)</span><br><span class="line">                    	.dematerialize();</span><br><span class="line">				&#125;</span><br><span class="line">				catch (Throwable cause) &#123;</span><br><span class="line">					return Flux.error(new IllegalArgumentException(&quot;Content of cache for key &quot; + key + &quot; cannot be cast to List&lt;Signal&gt;&quot;, cause));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return Flux.error(new IllegalArgumentException(&quot;Content of cache for key &quot; + key + &quot; is not a List&quot;));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的逻辑比较简单，其中<code>otherSupplier</code>实际上指的是<code>onCacheMissResume</code>方法中的参数；<code>Flux.defer</code>顾名思义，延迟加载，当需要的时候才进行加载。</p>
<p>首先，代码从cacheMap中拿到key对应的缓存内容，接下来就是进行判断，如果没有，则通过<code>otherSupplier</code>去读取数据源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (fromCache &#x3D;&#x3D; null) &#123;</span><br><span class="line">	return otherSupplier.get()</span><br><span class="line">		.materialize()</span><br><span class="line">		.collectList()</span><br><span class="line">		.doOnNext(signals -&gt; cacheMap.put(key, signals))</span><br><span class="line">		.flatMapIterable(Function.identity())</span><br><span class="line">		.dematerialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中有三个细节，一个是<code>materialize</code>方法，将对应数据<strong>具象化</strong>。我们知道，在reactive中Flux和Mono各种操作符，只是对数据做操作的描述，而不是数据对象本身，我们不能将操作符做缓存。做一个比方，我们各种操作符就相当于管道，而数据通过管道做对应的操作，最后形成所需要的内容，而所需要的内容被<code>subscibe()</code>方法消费，而真正的被消费的对象（或者说数据）则是源头对象中的<code>subscription</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final Flux&lt;Signal&lt;T&gt;&gt; materialize() &#123;</span><br><span class="line">	return onAssembly(new FluxMaterialize&lt;&gt;(this));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>materialize</code>我们将数据转换成<code>Signal&lt;T&gt;</code>，而这个<code>Singal</code>里则包含我们所需要消费的数据，即可作为消费的数据来源。</p>
<p>另外一个细节在<code>doOnNext</code>方法中,拿到<code>signals</code>对象后,将数据放回cacheMap中，所以我们<strong>无需在代码中显式的将数据插入缓存</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.doOnNext(signals -&gt; cacheMap.put(key, signals))</span><br></pre></td></tr></table></figure>
<p>第三个，则是<code>dematerialize()</code>，显然该方法与<code>materialize()</code>相对，是将将<code>Signal&lt;T&gt;</code>转换成<code>T</code>,进而进行下一步的操作或者消费。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final &lt;X&gt; Flux&lt;X&gt; dematerialize() &#123;</span><br><span class="line">	@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">	Flux&lt;Signal&lt;X&gt;&gt; thiz &#x3D; (Flux&lt;Signal&lt;X&gt;&gt;) this;</span><br><span class="line">	return onAssembly(new FluxDematerialize&lt;&gt;(thiz));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>从中我们发现<code>Singal</code>是一个容器，用于存放实际数据数据。</strong></p>
<p>接下来，我们来看如果在cacheMap中能够拿到key对应的缓存内容。如果是拿到的缓存是List对象，则进行类型转换，将<code>Signal&lt;T&gt;</code>转换成<code>T</code>，即<code>dematerialize()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">else if (fromCache instanceof List) &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">    	@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">		List&lt;Signal&lt;VALUE&gt;&gt; fromCacheSignals &#x3D; (List&lt;Signal&lt;VALUE&gt;&gt;) fromCache;</span><br><span class="line">		return Flux.fromIterable(fromCacheSignals)</span><br><span class="line">        	.dematerialize();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里我们就知道为什么通过直接缓存刷新之后，再使用缓存会报错？在刷新的代码中，直接将缓存类型<code>T</code>放入缓存，而不是<code>Signal&lt;T&gt;</code>，当再次使用缓存时候，自然不能做类型转换<code>(List&lt;Signal&lt;VALUE&gt;&gt;) fromCache</code>，于是报出类型转换错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.build(new CacheLoader&lt;String, Object&gt;() &#123;</span><br><span class="line">	@Override</span><br><span class="line">    public YourType load(String key) throws Exception &#123;</span><br><span class="line">    	return getYourTypeValue(key); &#x2F;&#x2F; 同步代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. cacheMap查询 -&gt; 如果没有 -&gt; 通过 onCacheMissResume中参数的方法查询数据 </span><br><span class="line">			-&gt; 通过materialize()方法将数据具象化，把T转换为Signal&lt;T&gt; </span><br><span class="line">            -&gt; 写入缓存map -&gt; 通过dematerialize()方法，反具象化，把Sinal&lt;T&gt;转T -&gt; 交给下步使用</span><br><span class="line"></span><br><span class="line">2. cacheMap查询 -&gt; 如果有 -&gt; 通过dematerialize()方法，反具象化，把Sinal&lt;T&gt;转T -&gt; 交给下步使用</span><br></pre></td></tr></table></figure>
<h3 id="如何改进？（课后题-D）"><a href="#如何改进？（课后题-D）" class="headerlink" title="如何改进？（课后题 :D）"></a>如何改进？（课后题 :D）</h3><p>从上面的代码分析我们可以看到，缓存中存放的是<code>Singal&lt;T&gt;</code>，所以我们需要将<code>T</code>转换成<code>Singal&lt;T&gt;</code>放入缓存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.build(new CacheLoader&lt;String, Object&gt;() &#123;</span><br><span class="line">	@Override</span><br><span class="line">    public YourType load(String key) throws Exception &#123;</span><br><span class="line">    	return Signal.next(getYourTypeValue(key)); &#x2F;&#x2F; 同步代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>通过<code>Signal.next(getYourTypeValue(key))</code>这样的方法，放入缓存后是否可用，待各位读者自行验证。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2021/01/13/Java8%E9%81%8D%E5%8E%86Map%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94for-stream-forEach/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2021 <a href="https://jevonyang.github.io">JevonYang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>